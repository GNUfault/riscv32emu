#include <stdio.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>
#include <sys/ioctl.h>
#include <termios.h>
#include <unistd.h>
#include <signal.h>
#include <sys/time.h>

uint32_t ram_amt = 64*1024*1024;
int fail_on_all_faults = 0;

static int64_t SimpleReadNumberInt(const char * number, int64_t defaultNumber);
static uint64_t GetTimeMicroseconds();
static void ResetKeyboardInput();
static void CaptureKeyboardInput();
static uint32_t HandleException(uint32_t ir, uint32_t retval);
static uint32_t HandleControlStore(uint32_t addy, uint32_t val);
static uint32_t HandleControlLoad(uint32_t addy);
static void HandleOtherCSRWrite(uint8_t * image, uint16_t csrno, uint32_t value);
static int32_t HandleOtherCSRRead(uint8_t * image, uint16_t csrno);
static void MiniSleep();
static int IsKBHit();
static int ReadKBByte();

struct RISCV32State {
	uint32_t regs[32];
	uint32_t pc;
	uint32_t mstatus;
	uint32_t cyclel;
	uint32_t cycleh;
	uint32_t timerl;
	uint32_t timerh;
	uint32_t timermatchl;
	uint32_t timermatchh;
	uint32_t mscratch;
	uint32_t mtvec;
	uint32_t mie;
	uint32_t mip;
	uint32_t mepc;
	uint32_t mtval;
	uint32_t mcause;
	uint32_t extraflags;
};

#define RISCV32WARN(x...) printf(x);
#define RISCV32_DECORATE  static
#define RISCV32_RAM_SIZE ram_amt
#define RISCV32_IMPLEMENTATION
#define RISCV32_POSTEXEC(pc, ir, retval) { if(retval > 0) { if(fail_on_all_faults) { printf("FAULT\n"); return 3; } else retval = HandleException(ir, retval); } }
#define RISCV32_HANDLE_MEM_STORE_CONTROL(addy, val) if(HandleControlStore(addy, val)) return val;
#define RISCV32_HANDLE_MEM_LOAD_CONTROL(addy, rval) rval = HandleControlLoad(addy);
#define RISCV32_OTHERCSR_WRITE(csrno, value) HandleOtherCSRWrite(image, csrno, value);
#define RISCV32_OTHERCSR_READ(csrno, value) value = HandleOtherCSRRead(image, csrno);

#ifndef RISCV32_RAM_IMAGE_OFFSET
	#define RISCV32_RAM_IMAGE_OFFSET  0x80000000
#endif

#ifndef RISCV32_STEPPROTO
	RISCV32_DECORATE int32_t RISCV32Step(struct RISCV32State * state, uint8_t * image, uint32_t vProcAddress, uint32_t elapsedUs, int count);
#endif

#ifndef RISCV32WARN
	#define RISCV32WARN(x...);
#endif

#ifndef RISCV32_DECORATE
	#define RISCV32_DECORATE static
#endif

#ifndef RISCV32_RAM_IMAGE_OFFSET
	#define RISCV32_RAM_IMAGE_OFFSET  0x80000000
#endif

#ifndef RISCV32_MMIO_RANGE
	#define RISCV32_MMIO_RANGE(n)  (0x10000000 <= (n) && (n) < 0x12000000)
#endif

#ifndef RISCV32_POSTEXEC
	#define RISCV32_POSTEXEC(...);
#endif

#ifndef RISCV32_HANDLE_MEM_STORE_CONTROL
	#define RISCV32_HANDLE_MEM_STORE_CONTROL(...);
#endif

#ifndef RISCV32_HANDLE_MEM_LOAD_CONTROL
	#define RISCV32_HANDLE_MEM_LOAD_CONTROL(...);
#endif

#ifndef RISCV32_OTHERCSR_WRITE
	#define RISCV32_OTHERCSR_WRITE(...);
#endif

#ifndef RISCV32_OTHERCSR_READ
	#define RISCV32_OTHERCSR_READ(...);
#endif

#define CSR(x) state->x
#define SETCSR(x, val) state->x = val
#define REGSET(x, val) state->regs[x] = val
#define REG(x) state->regs[x]

#ifndef RISCV32_CUSTOM_MEMORY_BUS
	#define RISCV32_STORE4(ofs, val) *(uint32_t*)(image + ofs) = val
	#define RISCV32_STORE2(ofs, val) *(uint16_t*)(image + ofs) = val
	#define RISCV32_STORE1(ofs, val) *(uint8_t*)(image + ofs) = val
	#define RISCV32_LOAD4(ofs) *(uint32_t*)(image + ofs)
	#define RISCV32_LOAD2(ofs) *(uint16_t*)(image + ofs)
	#define RISCV32_LOAD1(ofs) *(uint8_t*)(image + ofs)
	#define RISCV32_LOAD2_SIGNED(ofs) *(int16_t*)(image + ofs)
	#define RISCV32_LOAD1_SIGNED(ofs) *(int8_t*)(image + ofs)
#endif

#ifndef RISCV32_STEPPROTO
RISCV32_DECORATE int32_t RISCV32Step(struct RISCV32State * state, uint8_t * image, uint32_t vProcAddress, uint32_t elapsedUs, int count) {
#else
RISCV32_STEPPROTO {
#endif
	uint32_t new_timer = CSR(timerl) + elapsedUs;
	if(new_timer < CSR(timerl)) CSR(timerh)++;
	CSR(timerl) = new_timer;

	if((CSR(timerh) > CSR(timermatchh) || (CSR(timerh) == CSR(timermatchh) && CSR(timerl) > CSR(timermatchl))) && (CSR(timermatchh) || CSR(timermatchl))) {
		CSR(extraflags) &= ~4;
		CSR(mip) |= 1<<7;
	}
	else
		CSR(mip) &= ~(1<<7);

	if(CSR(extraflags) & 4)
		return 1;

	uint32_t trap = 0;
	uint32_t rval = 0;
	uint32_t pc = CSR(pc);
	uint32_t cycle = CSR(cyclel);

	if((CSR(mip) & (1<<7)) && (CSR(mie) & (1<<7)) && (CSR(mstatus) & 0x8)) {
		trap = 0x80000007;
		pc -= 4;
	}
	else
	for(int icount = 0; icount < count; icount++) {
		uint32_t ir = 0;
		rval = 0;
		cycle++;
		uint32_t ofs_pc = pc - RISCV32_RAM_IMAGE_OFFSET;

		if(ofs_pc >= RISCV32_RAM_SIZE) {
			trap = 1 + 1;
			break;
		}
		else if(ofs_pc & 3) {
			trap = 1 + 0;
			break;
		}
		else {
			ir = RISCV32_LOAD4(ofs_pc);
			uint32_t rdid = (ir >> 7) & 0x1f;

			switch(ir & 0x7f) {
				case 0x37:
					rval = (ir & 0xfffff000);
					break;
				case 0x17:
					rval = pc + (ir & 0xfffff000);
					break;
				case 0x6F: {
					int32_t reladdy = ((ir & 0x80000000)>>11) | ((ir & 0x7fe00000)>>20) | ((ir & 0x00100000)>>9) | ((ir&0x000ff000));
					if(reladdy & 0x00100000) reladdy |= 0xffe00000;
					rval = pc + 4;
					pc = pc + reladdy - 4;
					break;
				}
				case 0x67: {
					uint32_t imm = ir >> 20;
					int32_t imm_se = imm | ((imm & 0x800)?0xfffff000:0);
					rval = pc + 4;
					pc = ((REG((ir >> 15) & 0x1f) + imm_se) & ~1) - 4;
					break;
				}
				case 0x63: {
					uint32_t immm4 = ((ir & 0xf00)>>7) | ((ir & 0x7e000000)>>20) | ((ir & 0x80) << 4) | ((ir >> 31)<<12);
					if(immm4 & 0x1000) immm4 |= 0xffffe000;
					int32_t rs1 = REG((ir >> 15) & 0x1f);
					int32_t rs2 = REG((ir >> 20) & 0x1f);
					immm4 = pc + immm4 - 4;
					rdid = 0;
					switch((ir >> 12) & 0x7) {
						case 0: if(rs1 == rs2) pc = immm4; break;
						case 1: if(rs1 != rs2) pc = immm4; break;
						case 4: if(rs1 < rs2) pc = immm4; break;
						case 5: if(rs1 >= rs2) pc = immm4; break;
						case 6: if((uint32_t)rs1 < (uint32_t)rs2) pc = immm4; break;
						case 7: if((uint32_t)rs1 >= (uint32_t)rs2) pc = immm4; break;
						default: trap = (2+1);
					}
					break;
				}
				case 0x03: {
					uint32_t rs1 = REG((ir >> 15) & 0x1f);
					uint32_t imm = ir >> 20;
					int32_t imm_se = imm | ((imm & 0x800)?0xfffff000:0);
					uint32_t rsval = rs1 + imm_se;

					rsval -= RISCV32_RAM_IMAGE_OFFSET;
					if(rsval >= RISCV32_RAM_SIZE-3) {
						rsval += RISCV32_RAM_IMAGE_OFFSET;
						if(RISCV32_MMIO_RANGE(rsval)) {
							RISCV32_HANDLE_MEM_LOAD_CONTROL(rsval, rval);
						}
						else {
							trap = (5+1);
							rval = rsval;
						}
					}
					else {
						switch((ir >> 12) & 0x7) {
							case 0: rval = RISCV32_LOAD1_SIGNED(rsval); break;
							case 1: rval = RISCV32_LOAD2_SIGNED(rsval); break;
							case 2: rval = RISCV32_LOAD4(rsval); break;
							case 4: rval = RISCV32_LOAD1(rsval); break;
							case 5: rval = RISCV32_LOAD2(rsval); break;
							default: trap = (2+1);
						}
					}
					break;
				}
				case 0x23: {
					uint32_t rs1 = REG((ir >> 15) & 0x1f);
					uint32_t rs2 = REG((ir >> 20) & 0x1f);
					uint32_t addy = ((ir >> 7) & 0x1f) | ((ir & 0xfe000000) >> 20);
					if(addy & 0x800) addy |= 0xfffff000;
					addy += rs1 - RISCV32_RAM_IMAGE_OFFSET;
					rdid = 0;

					if(addy >= RISCV32_RAM_SIZE-3) {
						addy += RISCV32_RAM_IMAGE_OFFSET;
						if(RISCV32_MMIO_RANGE(addy)) {
							RISCV32_HANDLE_MEM_STORE_CONTROL(addy, rs2);
						}
						else {
							trap = (7+1);
							rval = addy;
						}
					}
					else {
						switch((ir >> 12) & 0x7) {
							case 0: RISCV32_STORE1(addy, rs2); break;
							case 1: RISCV32_STORE2(addy, rs2); break;
							case 2: RISCV32_STORE4(addy, rs2); break;
							default: trap = (2+1);
						}
					}
					break;
				}
				case 0x13:
				case 0x33: {
					uint32_t imm = ir >> 20;
					imm = imm | ((imm & 0x800)?0xfffff000:0);
					uint32_t rs1 = REG((ir >> 15) & 0x1f);
					uint32_t is_reg = !!(ir & 0x20);
					uint32_t rs2 = is_reg ? REG(imm & 0x1f) : imm;

					if(is_reg && (ir & 0x02000000)) {
						switch((ir>>12)&7) {
							case 0: rval = rs1 * rs2; break;
#ifndef CUSTOM_MULH
							case 1: rval = ((int64_t)((int32_t)rs1) * (int64_t)((int32_t)rs2)) >> 32; break;
							case 2: rval = ((int64_t)((int32_t)rs1) * (uint64_t)rs2) >> 32; break;
							case 3: rval = ((uint64_t)rs1 * (uint64_t)rs2) >> 32; break;
#else
							CUSTOM_MULH
#endif
							case 4: if(rs2 == 0) rval = -1; else rval = ((int32_t)rs1 == INT32_MIN && (int32_t)rs2 == -1) ? rs1 : ((int32_t)rs1 / (int32_t)rs2); break;
							case 5: if(rs2 == 0) rval = 0xffffffff; else rval = rs1 / rs2; break;
							case 6: if(rs2 == 0) rval = rs1; else rval = ((int32_t)rs1 == INT32_MIN && (int32_t)rs2 == -1) ? 0 : ((uint32_t)((int32_t)rs1 % (int32_t)rs2)); break;
							case 7: if(rs2 == 0) rval = rs1; else rval = rs1 % rs2; break;
						}
					}
					else {
						switch((ir>>12)&7) {
							case 0: rval = (is_reg && (ir & 0x40000000)) ? (rs1 - rs2) : (rs1 + rs2); break;
							case 1: rval = rs1 << (rs2 & 0x1F); break;
							case 2: rval = (int32_t)rs1 < (int32_t)rs2; break;
							case 3: rval = rs1 < rs2; break;
							case 4: rval = rs1 ^ rs2; break;
							case 5: rval = (ir & 0x40000000) ? (((int32_t)rs1) >> (rs2 & 0x1F)) : (rs1 >> (rs2 & 0x1F)); break;
							case 6: rval = rs1 | rs2; break;
							case 7: rval = rs1 & rs2; break;
						}
					}
					break;
				}
				case 0x0f:
					rdid = 0;
					break;
				case 0x73: {
					uint32_t csrno = ir >> 20;
					uint32_t microop = (ir >> 12) & 0x7;
					if((microop & 3)) {
						int rs1imm = (ir >> 15) & 0x1f;
						uint32_t rs1 = REG(rs1imm);
						uint32_t writeval = rs1;

						switch(csrno) {
						case 0x340: rval = CSR(mscratch); break;
						case 0x305: rval = CSR(mtvec); break;
						case 0x304: rval = CSR(mie); break;
						case 0xC00: rval = cycle; break;
						case 0x344: rval = CSR(mip); break;
						case 0x341: rval = CSR(mepc); break;
						case 0x300: rval = CSR(mstatus); break;
						case 0x342: rval = CSR(mcause); break;
						case 0x343: rval = CSR(mtval); break;
						case 0xf11: rval = 0xff0ff0ff; break;
						case 0x301: rval = 0x40401101; break;
						default:
							RISCV32_OTHERCSR_READ(csrno, rval);
							break;
						}

						switch(microop) {
							case 1: writeval = rs1; break;
							case 2: writeval = rval | rs1; break;
							case 3: writeval = rval & ~rs1; break;
							case 5: writeval = rs1imm; break;
							case 6: writeval = rval | rs1imm; break;
							case 7: writeval = rval & ~rs1imm; break;
						}

						switch(csrno) {
						case 0x340: SETCSR(mscratch, writeval); break;
						case 0x305: SETCSR(mtvec, writeval); break;
						case 0x304: SETCSR(mie, writeval); break;
						case 0x344: SETCSR(mip, writeval); break;
						case 0x341: SETCSR(mepc, writeval); break;
						case 0x300: SETCSR(mstatus, writeval); break;
						case 0x342: SETCSR(mcause, writeval); break;
						case 0x343: SETCSR(mtval, writeval); break;
						default:
							RISCV32_OTHERCSR_WRITE(csrno, writeval);
							break;
						}
					}
					else if(microop == 0x0) {
						rdid = 0;
						if(((csrno & 0xff) == 0x02)) {
							uint32_t startmstatus = CSR(mstatus);
							uint32_t startextraflags = CSR(extraflags);
							SETCSR(mstatus, ((startmstatus & 0x80) >> 4) | ((startextraflags&3) << 11) | 0x80);
							SETCSR(extraflags, (startextraflags & ~3) | ((startmstatus >> 11) & 3));
							pc = CSR(mepc) -4;
						} else {
							switch (csrno) {
							case 0:
								trap = (CSR(extraflags) & 3) ? (11+1) : (8+1);
								break;
							case 1:
								trap = (3+1); break;
							case 0x105:
								CSR(mstatus) |= 8;
								CSR(extraflags) |= 4;
								SETCSR(pc, pc + 4);
								return 1;
							default:
								trap = (2+1); break;
							}
						}
					}
					else
						trap = (2+1);
					break;
				}
				case 0x2f: {
					uint32_t rs1 = REG((ir >> 15) & 0x1f);
					uint32_t rs2 = REG((ir >> 20) & 0x1f);
					uint32_t irmid = (ir>>27) & 0x1f;

					rs1 -= RISCV32_RAM_IMAGE_OFFSET;

					if(rs1 >= RISCV32_RAM_SIZE-3) {
						trap = (7+1);
						rval = rs1 + RISCV32_RAM_IMAGE_OFFSET;
					}
					else {
						rval = RISCV32_LOAD4(rs1);

						uint32_t dowrite = 1;
						switch(irmid) {
							case 2:
								dowrite = 0;
								CSR(extraflags) = (CSR(extraflags) & 0x07) | (rs1<<3);
								break;
							case 3:
								rval = (CSR(extraflags) >> 3 != (rs1 & 0x1fffffff));
								dowrite = !rval;
								break;
							case 1: break;
							case 0: rs2 += rval; break;
							case 4: rs2 ^= rval; break;
							case 12: rs2 &= rval; break;
							case 8: rs2 |= rval; break;
							case 16: rs2 = ((int32_t)rs2<(int32_t)rval)?rs2:rval; break;
							case 20: rs2 = ((int32_t)rs2>(int32_t)rval)?rs2:rval; break;
							case 24: rs2 = (rs2<rval)?rs2:rval; break;
							case 28: rs2 = (rs2>rval)?rs2:rval; break;
							default: trap = (2+1); dowrite = 0; break;
						}
						if(dowrite) RISCV32_STORE4(rs1, rs2);
					}
					break;
				}
				default: trap = (2+1);
			}

			if(trap) {
				SETCSR(pc, pc);
				RISCV32_POSTEXEC(pc, ir, trap);
				break;
			}

			if(rdid) {
				REGSET(rdid, rval);
			}
		}

		RISCV32_POSTEXEC(pc, ir, trap);

		pc += 4;
	}

	if(trap) {
		if(trap & 0x80000000) {
			SETCSR(mcause, trap);
			SETCSR(mtval, 0);
			pc += 4;
		}
		else {
			SETCSR(mcause,  trap - 1);
			SETCSR(mtval, (trap > 5 && trap <= 8)? rval : pc);
		}
		SETCSR(mepc, pc);

		SETCSR(mstatus, ((CSR(mstatus) & 0x08) << 4) | ((CSR(extraflags) & 3) << 11));
		pc = (CSR(mtvec) - 4);

		CSR(extraflags) |= 3;

		trap = 0;
		pc += 4;
	}

	if(CSR(cyclel) > cycle) CSR(cycleh)++;
	SETCSR(cyclel, cycle);
	SETCSR(pc, pc);
	return 0;
}

uint8_t * ram_image = 0;
struct RISCV32State * core;
const char * kernel_command_line = 0;

static void DumpState(struct RISCV32State * core, uint8_t * ram_image);

static const unsigned char default64mbdtb[] = {0xd0, 0x0d, 0xfe, 0xed, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00, 0x38, 0x00, 0x00, 0x05, 0x00,
	0x00, 0x00, 0x00, 0x28, 0x00, 0x00, 0x00, 0x11, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0xe3, 0x00, 0x00, 0x04, 0xc8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02,
	0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x0f, 0x00, 0x00, 0x00, 0x02,
	0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 0x1b, 0x72, 0x69, 0x73, 0x63,
	0x76, 0x2d, 0x6d, 0x69, 0x6e, 0x69, 0x6d, 0x61, 0x6c, 0x2d, 0x6e, 0x6f, 0x6d, 0x6d, 0x75, 0x00,
	0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x19, 0x00, 0x00, 0x00, 0x26, 0x72, 0x69, 0x73, 0x63,
	0x76, 0x2d, 0x6d, 0x69, 0x6e, 0x69, 0x6d, 0x61, 0x6c, 0x2d, 0x6e, 0x6f, 0x6d, 0x6d, 0x75, 0x2c,
	0x71, 0x65, 0x6d, 0x75, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x63, 0x68, 0x6f, 0x73,
	0x65, 0x6e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x38, 0x00, 0x00, 0x00, 0x2c,
	0x65, 0x61, 0x72, 0x6c, 0x79, 0x63, 0x6f, 0x6e, 0x3d, 0x75, 0x61, 0x72, 0x74, 0x38, 0x32, 0x35,
	0x30, 0x2c, 0x6d, 0x6d, 0x69, 0x6f, 0x2c, 0x30, 0x78, 0x31, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30,
	0x30, 0x2c, 0x31, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x20, 0x63, 0x6f, 0x6e, 0x73, 0x6f, 0x6c,
	0x65, 0x3d, 0x74, 0x74, 0x79, 0x53, 0x30, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x01,
	0x6d, 0x65, 0x6d, 0x6f, 0x72, 0x79, 0x40, 0x38, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x00,
	0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x35, 0x6d, 0x65, 0x6d, 0x6f,
	0x72, 0x79, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x41,
	0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xff, 0xc0, 0x00,
	0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x01, 0x63, 0x70, 0x75, 0x73, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
	0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x0f, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x45, 0x00, 0x0f, 0x42, 0x40,
	0x00, 0x00, 0x00, 0x01, 0x63, 0x70, 0x75, 0x40, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03,
	0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x58, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x03,
	0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x35, 0x63, 0x70, 0x75, 0x00, 0x00, 0x00, 0x00, 0x03,
	0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x41, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03,
	0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x60, 0x6f, 0x6b, 0x61, 0x79, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x1b, 0x72, 0x69, 0x73, 0x63,
	0x76, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x67,
	0x72, 0x76, 0x33, 0x32, 0x69, 0x6d, 0x61, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x0b,
	0x00, 0x00, 0x00, 0x71, 0x72, 0x69, 0x73, 0x63, 0x76, 0x2c, 0x6e, 0x6f, 0x6e, 0x65, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x01, 0x69, 0x6e, 0x74, 0x65, 0x72, 0x72, 0x75, 0x70, 0x74, 0x2d, 0x63, 0x6f,
	0x6e, 0x74, 0x72, 0x6f, 0x6c, 0x6c, 0x65, 0x72, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03,
	0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x7a, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x03,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x8b, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x0f,
	0x00, 0x00, 0x00, 0x1b, 0x72, 0x69, 0x73, 0x63, 0x76, 0x2c, 0x63, 0x70, 0x75, 0x2d, 0x69, 0x6e,
	0x74, 0x63, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x58,
	0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x01,
	0x63, 0x70, 0x75, 0x2d, 0x6d, 0x61, 0x70, 0x00, 0x00, 0x00, 0x00, 0x01, 0x63, 0x6c, 0x75, 0x73,
	0x74, 0x65, 0x72, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x63, 0x6f, 0x72, 0x65,
	0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0xa0,
	0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x02,
	0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x01, 0x73, 0x6f, 0x63, 0x00, 0x00, 0x00, 0x00, 0x03,
	0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x03,
	0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x0f, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x03,
	0x00, 0x00, 0x00, 0x0b, 0x00, 0x00, 0x00, 0x1b, 0x73, 0x69, 0x6d, 0x70, 0x6c, 0x65, 0x2d, 0x62,
	0x75, 0x73, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xa4,
	0x00, 0x00, 0x00, 0x01, 0x75, 0x61, 0x72, 0x74, 0x40, 0x31, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30,
	0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0xab,
	0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x41,
	0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00,
	0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x1b, 0x6e, 0x73, 0x31, 0x36,
	0x38, 0x35, 0x30, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x01, 0x70, 0x6f, 0x77, 0x65,
	0x72, 0x6f, 0x66, 0x66, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x04,
	0x00, 0x00, 0x00, 0xbb, 0x00, 0x00, 0x55, 0x55, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x04,
	0x00, 0x00, 0x00, 0xc1, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x04,
	0x00, 0x00, 0x00, 0xc8, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x10,
	0x00, 0x00, 0x00, 0x1b, 0x73, 0x79, 0x73, 0x63, 0x6f, 0x6e, 0x2d, 0x70, 0x6f, 0x77, 0x65, 0x72,
	0x6f, 0x66, 0x66, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x01, 0x72, 0x65, 0x62, 0x6f,
	0x6f, 0x74, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0xbb,
	0x00, 0x00, 0x77, 0x77, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0xc1,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0xc8,
	0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x0e, 0x00, 0x00, 0x00, 0x1b,
	0x73, 0x79, 0x73, 0x63, 0x6f, 0x6e, 0x2d, 0x72, 0x65, 0x62, 0x6f, 0x6f, 0x74, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x01, 0x73, 0x79, 0x73, 0x63, 0x6f, 0x6e, 0x40, 0x31,
	0x31, 0x31, 0x30, 0x30, 0x30, 0x30, 0x30, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x04,
	0x00, 0x00, 0x00, 0x58, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x10,
	0x00, 0x00, 0x00, 0x41, 0x00, 0x00, 0x00, 0x00, 0x11, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x1b,
	0x73, 0x79, 0x73, 0x63, 0x6f, 0x6e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x01,
	0x63, 0x6c, 0x69, 0x6e, 0x74, 0x40, 0x31, 0x31, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0xcf, 0x00, 0x00, 0x00, 0x02,
	0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x03,
	0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x41, 0x00, 0x00, 0x00, 0x00, 0x11, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x1b,
	0x00, 0x00, 0x00, 0x1b, 0x73, 0x69, 0x66, 0x69, 0x76, 0x65, 0x2c, 0x63, 0x6c, 0x69, 0x6e, 0x74,
	0x30, 0x00, 0x72, 0x69, 0x73, 0x63, 0x76, 0x2c, 0x63, 0x6c, 0x69, 0x6e, 0x74, 0x30, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x09,
	0x23, 0x61, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x2d, 0x63, 0x65, 0x6c, 0x6c, 0x73, 0x00, 0x23,
	0x73, 0x69, 0x7a, 0x65, 0x2d, 0x63, 0x65, 0x6c, 0x6c, 0x73, 0x00, 0x63, 0x6f, 0x6d, 0x70, 0x61,
	0x74, 0x69, 0x62, 0x6c, 0x65, 0x00, 0x6d, 0x6f, 0x64, 0x65, 0x6c, 0x00, 0x62, 0x6f, 0x6f, 0x74,
	0x61, 0x72, 0x67, 0x73, 0x00, 0x64, 0x65, 0x76, 0x69, 0x63, 0x65, 0x5f, 0x74, 0x79, 0x70, 0x65,
	0x00, 0x72, 0x65, 0x67, 0x00, 0x74, 0x69, 0x6d, 0x65, 0x62, 0x61, 0x73, 0x65, 0x2d, 0x66, 0x72,
	0x65, 0x71, 0x75, 0x65, 0x6e, 0x63, 0x79, 0x00, 0x70, 0x68, 0x61, 0x6e, 0x64, 0x6c, 0x65, 0x00,
	0x73, 0x74, 0x61, 0x74, 0x75, 0x73, 0x00, 0x72, 0x69, 0x73, 0x63, 0x76, 0x2c, 0x69, 0x73, 0x61,
	0x00, 0x6d, 0x6d, 0x75, 0x2d, 0x74, 0x79, 0x70, 0x65, 0x00, 0x23, 0x69, 0x6e, 0x74, 0x65, 0x72,
	0x72, 0x75, 0x70, 0x74, 0x2d, 0x63, 0x65, 0x6c, 0x6c, 0x73, 0x00, 0x69, 0x6e, 0x74, 0x65, 0x72,
	0x72, 0x75, 0x70, 0x74, 0x2d, 0x63, 0x6f, 0x6e, 0x74, 0x72, 0x6f, 0x6c, 0x6c, 0x65, 0x72, 0x00,
	0x63, 0x70, 0x75, 0x00, 0x72, 0x61, 0x6e, 0x67, 0x65, 0x73, 0x00, 0x63, 0x6c, 0x6f, 0x63, 0x6b,
	0x2d, 0x66, 0x72, 0x65, 0x71, 0x75, 0x65, 0x6e, 0x63, 0x79, 0x00, 0x76, 0x61, 0x6c, 0x75, 0x65,
	0x00, 0x6f, 0x66, 0x66, 0x73, 0x65, 0x74, 0x00, 0x72, 0x65, 0x67, 0x6d, 0x61, 0x70, 0x00, 0x69,
	0x6e, 0x74, 0x65, 0x72, 0x72, 0x75, 0x70, 0x74, 0x73, 0x2d, 0x65, 0x78, 0x74, 0x65, 0x6e, 0x64,
	0x65, 0x64, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
};

int main(int argc, char ** argv) {
	int i;
	long long instct = -1;
	int show_help = 0;
	int time_divisor = 1;
	int fixed_update = 0;
	int do_sleep = 1;
	int single_step = 0;
	int dtb_ptr = 0;
	const char * image_file_name = 0;
	const char * dtb_file_name = 0;
	for(i = 1; i < argc; i++) {
		const char * param = argv[i];
		int param_continue = 0;
		do {
			if(param[0] == '-' || param_continue) {
				switch(param[1]) {
				case 'm': if(++i < argc) ram_amt = SimpleReadNumberInt(argv[i], ram_amt); break;
				case 'c': if(++i < argc) instct = SimpleReadNumberInt(argv[i], -1); break;
				case 'k': if(++i < argc) kernel_command_line = argv[i]; break;
				case 'f': image_file_name = (++i<argc)?argv[i]:0; break;
				case 'b': dtb_file_name = (++i<argc)?argv[i]:0; break;
				case 'l': param_continue = 1; fixed_update = 1; break;
				case 'p': param_continue = 1; do_sleep = 0; break;
				case 's': param_continue = 1; single_step = 1; break;
				case 'd': param_continue = 1; fail_on_all_faults = 1; break;
				case 't': if(++i < argc) time_divisor = SimpleReadNumberInt(argv[i], 1); break;
				default:
					if(param_continue)
						param_continue = 0;
					else
						show_help = 1;
					break;
				}
			}
			else {
				show_help = 1;
				break;
			}
			param++;
		} while(param_continue);
	}
	if(show_help || image_file_name == 0 || time_divisor <= 0) {
		fprintf(stderr, "./riscv32emu [parameters]\n\t-m [ram amount]\n\t-f [running image]\n\t-k [kernel command line]\n\t-b [dtb file, or 'disable']\n\t-c instruction count\n\t-s single step with full processor state\n\t-t time divion base\n\t-l lock time base to instruction count\n\t-p disable sleep when wfi\n\t-d fail out immediately on all faults\n");
		return 1;
	}

	ram_image = malloc(ram_amt);
	if(!ram_image) {
		fprintf(stderr, "Error: could not allocate system image.\n");
		return -4;
	}

restart:
	{
		FILE * f = fopen(image_file_name, "rb");
		if(!f || ferror(f)) {
			fprintf(stderr, "Error: \"%s\" not found\n", image_file_name);
			return -5;
		}
		fseek(f, 0, SEEK_END);
		long flen = ftell(f);
		fseek(f, 0, SEEK_SET);
		if(flen > ram_amt) {
			fprintf(stderr, "Error: Could not fit RAM image (%ld bytes) into %d\n", flen, ram_amt);
			return -6;
		}

		memset(ram_image, 0, ram_amt);
		if(fread(ram_image, flen, 1, f) != 1) {
			fprintf(stderr, "Error: Could not load image.\n");
			return -7;
		}
		fclose(f);

		if(dtb_file_name) {
			if(strcmp(dtb_file_name, "disable") == 0) {

			}
			else {
				f = fopen(dtb_file_name, "rb");
				if(!f || ferror(f)) {
					fprintf(stderr, "Error: \"%s\" not found\n", dtb_file_name);
					return -5;
				}
				fseek(f, 0, SEEK_END);
				long dtblen = ftell(f);
				fseek(f, 0, SEEK_SET);
				dtb_ptr = ram_amt - dtblen - sizeof(struct RISCV32State);
				if(fread(ram_image + dtb_ptr, dtblen, 1, f) != 1) {
					fprintf(stderr, "Error: Could not open dtb \"%s\"\n", dtb_file_name);
					return -9;
				}
				fclose(f);
			}
		}
		else {
			dtb_ptr = ram_amt - sizeof(default64mbdtb) - sizeof(struct RISCV32State);
			memcpy(ram_image + dtb_ptr, default64mbdtb, sizeof(default64mbdtb));
			if(kernel_command_line) {
				strncpy((char*)(ram_image + dtb_ptr + 0xc0), kernel_command_line, 54);
			}
		}
	}

	CaptureKeyboardInput();

	core = (struct RISCV32State *)(ram_image + ram_amt - sizeof(struct RISCV32State));
	core->pc = RISCV32_RAM_IMAGE_OFFSET;
	core->regs[10] = 0x00;
	core->regs[11] = dtb_ptr?(dtb_ptr+RISCV32_RAM_IMAGE_OFFSET):0;
	core->extraflags |= 3;

	if(dtb_file_name == 0) {
		uint32_t * dtb = (uint32_t*)(ram_image + dtb_ptr);
		if(dtb[0x13c/4] == 0x00c0ff03) {
			uint32_t validram = dtb_ptr;
			dtb[0x13c/4] = (validram>>24) | (((validram >> 16) & 0xff) << 8) | (((validram>>8) & 0xff) << 16) | ((validram & 0xff) << 24);
		}
	}

	uint64_t rt;
	uint64_t lastTime = (fixed_update)?0:(GetTimeMicroseconds()/time_divisor);
	int instrs_per_flip = single_step?1:1024;
	for(rt = 0; rt < instct+1 || instct < 0; rt += instrs_per_flip) {
		uint64_t * this_ccount = ((uint64_t*)&core->cyclel);
		uint32_t elapsedUs = 0;
		if(fixed_update)
			elapsedUs = *this_ccount / time_divisor - lastTime;
		else
			elapsedUs = GetTimeMicroseconds()/time_divisor - lastTime;
		lastTime += elapsedUs;

		if(single_step)
			DumpState(core, ram_image);

		int ret = RISCV32Step(core, ram_image, 0, elapsedUs, instrs_per_flip);
		switch(ret) {
			case 0: break;
			case 1: if(do_sleep) MiniSleep(); *this_ccount+= instrs_per_flip; break;
			case 3: instct = 0; break;
			case 0x7777: goto restart;
			case 0x5555: printf("POWEROFF@0x%08x%08x\n", core->cycleh, core->cyclel); return 0;
			default: printf("Unknown failure\n"); break;
		}
	}

	DumpState(core, ram_image);
}

static void CtrlC(int sig) {
	puts("");
	exit(0);
}

static void CaptureKeyboardInput() {
	atexit(ResetKeyboardInput);
	signal(SIGINT, CtrlC);

	struct termios term;
	tcgetattr(0, &term);
	term.c_lflag &= ~(ICANON | ECHO);
	tcsetattr(0, TCSANOW, &term);
}

static void ResetKeyboardInput() {
	struct termios term;
	tcgetattr(0, &term);
	term.c_lflag |= ICANON | ECHO;
	tcsetattr(0, TCSANOW, &term);
}

static void MiniSleep() {
	sleep(0.5);
}

static uint64_t GetTimeMicroseconds() {
	struct timeval tv;
	gettimeofday(&tv, 0);
	return tv.tv_usec + ((uint64_t)(tv.tv_sec)) * 1000000LL;
}

static int is_eofd;

static int ReadKBByte() {
	if(is_eofd) return 0xffffffff;
	char rxchar = 0;
	int rread = read(STDIN_FILENO, (char*)&rxchar, 1);

	if(rread > 0)
		return rxchar;
	else
		return -1;
}

static int IsKBHit() {
	if(is_eofd) return -1;
	int byteswaiting;
	ioctl(0, FIONREAD, &byteswaiting);
	if(!byteswaiting && write(STDIN_FILENO, 0, 0) != 0) { is_eofd = 1; return -1; }
	return !!byteswaiting;
}

static uint32_t HandleException(uint32_t ir, uint32_t code) {
	if(code == 3) {

	}
	return code;
}

static uint32_t HandleControlStore(uint32_t addy, uint32_t val) {
	if(addy == 0x10000000) {
		printf("%c", val);
		fflush(stdout);
	}
	else if(addy == 0x11004004)
		core->timermatchh = val;
	else if(addy == 0x11004000)
		core->timermatchl = val;
	else if(addy == 0x11100000) {
		core->pc = core->pc + 4;
		return val;
	}
	return 0;
}

static uint32_t HandleControlLoad(uint32_t addy) {
	if(addy == 0x10000005)
		return 0x60 | IsKBHit();
	else if(addy == 0x10000000 && IsKBHit())
		return ReadKBByte();
	else if(addy == 0x1100bffc)
		return core->timerh;
	else if(addy == 0x1100bff8)
		return core->timerl;
	return 0;
}

static void HandleOtherCSRWrite(uint8_t * image, uint16_t csrno, uint32_t value) {
	if(csrno == 0x136) {
		printf("%d", value); fflush(stdout);
	}
	if(csrno == 0x137) {
		printf("%08x", value); fflush(stdout);
	}
	else if(csrno == 0x138) {
		uint32_t ptrstart = value - RISCV32_RAM_IMAGE_OFFSET;
		uint32_t ptrend = ptrstart;
		if(ptrstart >= ram_amt)
			printf("DEBUG PASSED INVALID PTR (%08x)\n", value);
		while(ptrend < ram_amt) {
			if(image[ptrend] == 0) break;
			ptrend++;
		}
		if(ptrend != ptrstart)
			fwrite(image + ptrstart, ptrend - ptrstart, 1, stdout);
	}
	else if(csrno == 0x139) {
		putchar(value); fflush(stdout);
	}
}

static int32_t HandleOtherCSRRead(uint8_t * image, uint16_t csrno) {
	if(csrno == 0x140) {
		if(!IsKBHit()) return -1;
		return ReadKBByte();
	}
	return 0;
}

static int64_t SimpleReadNumberInt(const char * number, int64_t defaultNumber) {
	if(!number || !number[0]) return defaultNumber;
	int radix = 10;
	if(number[0] == '0') {
		char nc = number[1];
		number+=2;
		if(nc == 0) return 0;
		else if(nc == 'x') radix = 16;
		else if(nc == 'b') radix = 2;
		else { number--; radix = 8; }
	}
	char * endptr;
	uint64_t ret = strtoll(number, &endptr, radix);
	if(endptr == number) {
		return defaultNumber;
	}
	else {
		return ret;
	}
}

static void DumpState(struct RISCV32State * core, uint8_t * ram_image) {
	uint32_t pc = core->pc;
	uint32_t pc_offset = pc - RISCV32_RAM_IMAGE_OFFSET;
	uint32_t ir = 0;

	printf("PC: %08x ", pc);
	if(pc_offset >= 0 && pc_offset < ram_amt - 3) {
		ir = *((uint32_t*)(&((uint8_t*)ram_image)[pc_offset]));
		printf("[0x%08x] ", ir);
	}
	else
		printf("[xxxxxxxxxx] ");
	uint32_t * regs = core->regs;
	printf("Z:%08x ra:%08x sp:%08x gp:%08x tp:%08x t0:%08x t1:%08x t2:%08x s0:%08x s1:%08x a0:%08x a1:%08x a2:%08x a3:%08x a4:%08x a5:%08x ",
		regs[0], regs[1], regs[2], regs[3], regs[4], regs[5], regs[6], regs[7],
		regs[8], regs[9], regs[10], regs[11], regs[12], regs[13], regs[14], regs[15]);
	printf("a6:%08x a7:%08x s2:%08x s3:%08x s4:%08x s5:%08x s6:%08x s7:%08x s8:%08x s9:%08x s10:%08x s11:%08x t3:%08x t4:%08x t5:%08x t6:%08x\n",
		regs[16], regs[17], regs[18], regs[19], regs[20], regs[21], regs[22], regs[23],
		regs[24], regs[25], regs[26], regs[27], regs[28], regs[29], regs[30], regs[31]);
}
